// +build !ignore_autogenerated

/*
Copyright isaaguilar.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1alpha1

import (
	spec "github.com/go-openapi/spec"
	common "k8s.io/kube-openapi/pkg/common"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.Terraform":       schema_pkg_apis_tf_v1alpha1_Terraform(ref),
		"github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.TerraformSpec":   schema_pkg_apis_tf_v1alpha1_TerraformSpec(ref),
		"github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.TerraformStatus": schema_pkg_apis_tf_v1alpha1_TerraformStatus(ref),
	}
}

func schema_pkg_apis_tf_v1alpha1_Terraform(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Terraform is the Schema for the terraforms API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.TerraformSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.TerraformStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.TerraformSpec", "github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.TerraformStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_tf_v1alpha1_TerraformSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TerraformSpec defines the desired state of Terraform",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"keepCompletedPods": {
						SchemaProps: spec.SchemaProps{
							Description: "KeepCompletedPods when true will keep completed pods. Default is false and completed pods are removed.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"runnerRules": {
						SchemaProps: spec.SchemaProps{
							Description: "RunnerRules are RBAC rules that will be added to all runner pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/rbac/v1.PolicyRule"),
									},
								},
							},
						},
					},
					"runnerAnnotations": {
						SchemaProps: spec.SchemaProps{
							Description: "RunnerAnnotations are annotations that will be added to all runner pods.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"terraformVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformVersion helps the operator decide which image tag to pull for the terraform runner. Defaults to \"0.11.14\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scriptRunnerVersion": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"setupRunnerVersion": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"terraformRunner": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformRunner gives the user the ability to inject their own container image to execute terraform. This is very helpful for users who need to have a certain toolset installed on their images, or who can't pull public images, such as the default image \"isaaguilar/tfops\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scriptRunner": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"setupRunner": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"terraformRunnerExecutionScriptConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformRunnerExecutionScriptConfigMap allows the user to define a custom terraform runner script that gets executed instead of the default script built into the runner image. The configmap \"name\" and \"key\" are required.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"scriptRunnerExecutionScriptConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "ScriptRunnerExecutionScriptConfigMap allows the user to define a custom terraform runner script that gets executed instead of the default script built into the runner image. The configmap \"name\" and \"key\" are required.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"setupRunnerExecutionScriptConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "SetupRunnerExecutionScriptConfigMap allows the user to define a custom terraform runner script that gets executed instead of the default script built into the runner image. The configmap \"name\" and \"key\" are required.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"terraformRunnerPullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformRunnerPullPolicy describes a policy for if/when to pull the TerraformRunner image. Acceptable values are \"Always\", \"Never\", or \"IfNotPresent\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scriptRunnerPullPolicy": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"setupRunnerPullPolicy": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"terraformModule": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformModule is the terraform module scm address. Currently supports git protocol over SSH or HTTPS.\n\nPrecedence of \"terraformModule*\" to use as the main module is determined by the setup runner. See the runners/setup.sh for the module configuration.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terraformModuleConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformModuleConfigMap is the configMap that contains terraform module resources. The module will be fetched by the setup runner. In order for terraform to understand it's a module reosurce, the configmap keys must end in `.tf` or `.tf.json`.",
							Ref:         ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ConfigMapSelector"),
						},
					},
					"terraformModuleInline": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformModuleInline is an incline terraform module definition. The contents of the inline definition will be used to create `inline-module.tf`",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"outputsSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "OutputsSecret will create a secret with the outputs from the module. All outputs from the module will be written to the secret unless the user defines \"outputsToInclude\" or \"outputsToOmit\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"outputsToInclude": {
						SchemaProps: spec.SchemaProps{
							Description: "OutputsToInclude is a whitelist of outputs to write when writing the outputs to kubernetes.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"outputsToOmit": {
						SchemaProps: spec.SchemaProps{
							Description: "OutputsToOmit is a blacklist of outputs to omit when writing the outputs to kubernetes.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"writeOutputsToStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "WriteOutputsToStatus will add the outputs from the module to the status of the Terraform CustomResource.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"resourceDownloads": {
						SchemaProps: spec.SchemaProps{
							Description: "ResourceDownloads defines other files to download into the module directory that can be used by the terraform workflow runners. The `tfvar` type will also be fetched by the `exportRepo` option (if defined) to aggregate the set of tfvars to save to an scm system.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ResourceDownload"),
									},
								},
							},
						},
					},
					"env": {
						SchemaProps: spec.SchemaProps{
							Description: "Env is used to define a common set of environment variables into the workflow runners. The `TF_VAR_` prefix will also be used by the `exportRepo` option.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccount use a specific kubernetes ServiceAccount for running the create + destroy pods. If not specified we create a new ServiceAccount per Terraform",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"credentials": {
						SchemaProps: spec.SchemaProps{
							Description: "Credentials is an array of credentials generally used for Terraform providers",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.Credentials"),
									},
								},
							},
						},
					},
					"ignoreDelete": {
						SchemaProps: spec.SchemaProps{
							Description: "IgnoreDelete will bypass the finalization process and remove the tf resource without running any delete jobs.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"reconcile": {
						SchemaProps: spec.SchemaProps{
							Description: "Reconcile are the settings used for auto-reconciliation",
							Ref:         ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ReconcileTerraformDeployment"),
						},
					},
					"customBackend": {
						SchemaProps: spec.SchemaProps{
							Description: "CustomBackend will allow the user to configure the backend of their choice. If this is omitted, the default consul template will be used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"exportRepo": {
						SchemaProps: spec.SchemaProps{
							Description: "ExportRepo allows the user to define",
							Ref:         ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ExportRepo"),
						},
					},
					"preInitScript": {
						SchemaProps: spec.SchemaProps{
							Description: "PreInitScript lets the user define a script that will run before terraform commands are executed on the terraform-execution pod. The pod will have already set up cloudProfile (eg cloud credentials) so the script can make use of it.\n\nSetting this field will create a key in the tfvars configmap called \"prerun.sh\". This means the user can also pass in a prerun.sh file via config \"Sources\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"postInitScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"prePlanScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"postPlanScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"preApplyScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"postApplyScript": {
						SchemaProps: spec.SchemaProps{
							Description: "PostApplyScript lets the user define a script that will run after terraform commands are executed on the terraform-execution pod. The pod will have already set up cloudProfile (eg cloud credentials) so the script can make use of it.\n\nSetting this field will create a key in the tfvars configmap called \"postrun.sh\". This means the user can alternatively pass in a posterun.sh file via config \"Sources\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"preInitDeleteScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"postInitDeleteScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"prePlanDeleteScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"postPlanDeleteScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"preApplyDeleteScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"postApplyDeleteScript": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"sshTunnel": {
						SchemaProps: spec.SchemaProps{
							Description: "SSHTunnel can be defined for pulling from scm sources that cannot be accessed by the network the operator/runner runs in. An example is Enterprise Github servers running on a private network.",
							Ref:         ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ProxyOpts"),
						},
					},
					"scmAuthMethods": {
						SchemaProps: spec.SchemaProps{
							Description: "SCMAuthMethods define multiple SCMs that require tokens/keys",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.SCMAuthMethod"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ConfigMapSelector", "github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.Credentials", "github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ExportRepo", "github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ProxyOpts", "github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ReconcileTerraformDeployment", "github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.ResourceDownload", "github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.SCMAuthMethod", "k8s.io/api/core/v1.ConfigMapKeySelector", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/rbac/v1.PolicyRule"},
	}
}

func schema_pkg_apis_tf_v1alpha1_TerraformStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TerraformStatus defines the observed state of Terraform",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podNamePrefix": {
						SchemaProps: spec.SchemaProps{
							Description: "PodNamePrefix is used to identify this installation of the resource. For very long resource names, like those greater than 220 characters, the prefix ensures resource uniqueness for runners and other resources used by the runner. Another case for the pod name prefix is when rapidly deleteing a resource and recreating it, the chance of recycling existing resources is reduced to virtually nil.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"lastCompletedGeneration": {
						SchemaProps: spec.SchemaProps{
							Default: 0,
							Type:    []string{"integer"},
							Format:  "int64",
						},
					},
					"outputs": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"stages": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.Stage"),
									},
								},
							},
						},
					},
					"exported": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"podNamePrefix", "phase", "lastCompletedGeneration", "stages"},
			},
		},
		Dependencies: []string{
			"github.com/isaaguilar/terraform-operator/pkg/apis/tf/v1alpha1.Stage"},
	}
}
