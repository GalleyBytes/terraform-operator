//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright isaaguilar.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1beta1

import (
	common "k8s.io/kube-openapi/pkg/common"
	spec "k8s.io/kube-openapi/pkg/validation/spec"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.AWSCredentials":    schema_pkg_apis_tf_v1beta1_AWSCredentials(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ConfigMapSelector": schema_pkg_apis_tf_v1beta1_ConfigMapSelector(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Credentials":       schema_pkg_apis_tf_v1beta1_Credentials(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitHTTPS":          schema_pkg_apis_tf_v1beta1_GitHTTPS(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitSCM":            schema_pkg_apis_tf_v1beta1_GitSCM(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitSSH":            schema_pkg_apis_tf_v1beta1_GitSSH(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ImageConfig":       schema_pkg_apis_tf_v1beta1_ImageConfig(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Images":            schema_pkg_apis_tf_v1beta1_Images(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Module":            schema_pkg_apis_tf_v1beta1_Module(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Plugin":            schema_pkg_apis_tf_v1beta1_Plugin(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ProxyOpts":         schema_pkg_apis_tf_v1beta1_ProxyOpts(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ResourceDownload":  schema_pkg_apis_tf_v1beta1_ResourceDownload(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SCMAuthMethod":     schema_pkg_apis_tf_v1beta1_SCMAuthMethod(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SSHKeySecretRef":   schema_pkg_apis_tf_v1beta1_SSHKeySecretRef(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SecretNameRef":     schema_pkg_apis_tf_v1beta1_SecretNameRef(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Setup":             schema_pkg_apis_tf_v1beta1_Setup(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Stage":             schema_pkg_apis_tf_v1beta1_Stage(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.StageScript":       schema_pkg_apis_tf_v1beta1_StageScript(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TaskOption":        schema_pkg_apis_tf_v1beta1_TaskOption(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Terraform":         schema_pkg_apis_tf_v1beta1_Terraform(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TerraformSpec":     schema_pkg_apis_tf_v1beta1_TerraformSpec(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TerraformStatus":   schema_pkg_apis_tf_v1beta1_TerraformStatus(ref),
		"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TokenSecretRef":    schema_pkg_apis_tf_v1beta1_TokenSecretRef(ref),
	}
}

func schema_pkg_apis_tf_v1beta1_AWSCredentials(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AWSCredentials provides a few different k8s-specific methods of adding crednetials to pods. This includes KIAM and IRSA.\n\nTo use environment variables, use a secretNameRef instead.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"irsa": {
						SchemaProps: spec.SchemaProps{
							Description: "IRSA requires the irsa role-arn as the string input. This will create a serice account named tf-<resource-name>. In order for the pod to be able to use this role, the \"Trusted Entity\" of the IAM role must allow this serice account name and namespace.\n\nUsing a TrustEntity policy that includes \"StringEquals\" setting it as the serivce account name is the most secure way to use IRSA.\n\nHowever, for a reusable policy consider \"StringLike\" with a few wildcards to make the irsa role usable by pods created by terraform-operator. The example below is pretty liberal, but will work for any pod created by the terraform-operator.\n\n```json\n  {\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n      {\n        \"Effect\": \"Allow\",\n        \"Principal\": {\n          \"Federated\": \"${OIDC_ARN}\"\n        },\n        \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n        \"Condition\": {\n          \"StringLike\": {\n            \"${OIDC_URL}:sub\": \"system:serviceaccount:*:tf-*\"\n          }\n        }\n      }\n    ]\n  }\n```\n\n<note>This option is just a specialized version of Credentials.ServiceAccountAnnotations and will be a candidate of removal in the future.</note>",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kiam": {
						SchemaProps: spec.SchemaProps{
							Description: "KIAM requires the kiam role-name as the string input. This will add the correct annotation to the terraform execution pod\n\n<note>This option is just a specialized version of Credentials.ServiceAccountAnnotations and will be a candidate of removal in the future.</note>",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_tf_v1beta1_ConfigMapSelector(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "A simple selector for configmaps that can select on the name of the configmap with the optional key. The namespace is not an option since only runners with a namespace'd role will utilize this map.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"key": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"name"},
			},
		},
	}
}

func schema_pkg_apis_tf_v1beta1_Credentials(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Credentials are used for adding credentials for terraform providers. For example, in AWS, the AWS Terraform Provider uses the default credential chain of the AWS SDK, one of which are environment variables (eg AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY)",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"secretNameRef": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretNameRef will load environment variables into the terraform runner from a kubernetes secret",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SecretNameRef"),
						},
					},
					"aws": {
						SchemaProps: spec.SchemaProps{
							Description: "AWSCredentials contains the different methods to load AWS credentials for the Terraform AWS Provider. If using AWS_ACCESS_KEY_ID and/or environment variables for credentials, use fromEnvs.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.AWSCredentials"),
						},
					},
					"serviceAccountAnnotations": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountAnnotations allows the service account to be annotated with cloud IAM roles such as Workload Identity on GCP",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.AWSCredentials", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SecretNameRef"},
	}
}

func schema_pkg_apis_tf_v1beta1_GitHTTPS(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GitHTTPS configures the setup for git over https using tokens. Proxy is not supported in the terraform job pod at this moment",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"requireProxy": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"boolean"},
							Format: "",
						},
					},
					"tokenSecretRef": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TokenSecretRef"),
						},
					},
				},
				Required: []string{"tokenSecretRef"},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TokenSecretRef"},
	}
}

func schema_pkg_apis_tf_v1beta1_GitSCM(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GitSCM define the auth methods of git",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ssh": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitSSH"),
						},
					},
					"https": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitHTTPS"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitHTTPS", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitSSH"},
	}
}

func schema_pkg_apis_tf_v1beta1_GitSSH(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GitSSH configurs the setup for git over ssh with optional proxy",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"requireProxy": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"boolean"},
							Format: "",
						},
					},
					"sshKeySecretRef": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SSHKeySecretRef"),
						},
					},
				},
				Required: []string{"sshKeySecretRef"},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SSHKeySecretRef"},
	}
}

func schema_pkg_apis_tf_v1beta1_ImageConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ImageConfig describes a task class's container image and image pull policy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "The container image from the registry; tags must be omitted",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"image"},
			},
		},
	}
}

func schema_pkg_apis_tf_v1beta1_Images(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Images describes the container images used by task classes",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"terraform": {
						SchemaProps: spec.SchemaProps{
							Description: "Terraform task type container image definition",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ImageConfig"),
						},
					},
					"script": {
						SchemaProps: spec.SchemaProps{
							Description: "Script task type container image definition",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ImageConfig"),
						},
					},
					"setup": {
						SchemaProps: spec.SchemaProps{
							Description: "Setup task type container image definition",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ImageConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ImageConfig"},
	}
}

func schema_pkg_apis_tf_v1beta1_Module(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Module has the different types of ways to define a terraform module. The order of precendence is\n 1. inline\n 2. configMapSelector\n 3. source[/version]",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"source": {
						SchemaProps: spec.SchemaProps{
							Description: "Source accepts a subset of the terraform \"Module Source\" ways of defining a module. Terraform Operator prefers modules that are defined in a git repo as opposed to other scm types. Refer to https://www.terraform.io/language/modules/sources#module-sources for more details.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version to select from a terraform registry. For version to be used, source must be defined. Refer to https://www.terraform.io/language/modules/sources#module-sources for more details",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configMapSeclector": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMapSelector is an option that points to an existing configmap on the executing cluster. The configmap is expected to contains has the terraform module (ie keys ending with .tf). The configmap would need to live in the same namespace as the tfo resource.\n\nThe configmap is mounted as a volume and put into the TFO_MAIN_MODULE path by the setup task.\n\nIf a key is defined, the value is used as the module else the entirety of the data objects will be loaded as files.",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ConfigMapSelector"),
						},
					},
					"inline": {
						SchemaProps: spec.SchemaProps{
							Description: "Inline used to define an entire terraform module inline and then mounted in the TFO_MAIN_MODULE path.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ConfigMapSelector"},
	}
}

func schema_pkg_apis_tf_v1beta1_Plugin(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Plugin Define additional pods to run during a workflow",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "The container image from the registry; tags must be omitted",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"when": {
						SchemaProps: spec.SchemaProps{
							Description: "When is a keyword of a two-part selector of when the plugin gets run in the workflow. The value must be one of\n\n- <code>At</code> to run at the same time as the defined task\n\n- <code>After</code> to run after the defined task has completed.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"task": {
						SchemaProps: spec.SchemaProps{
							Description: "Task is the second part of a two-part selector of when the plugin gets run in the workflow. This should correspond to one of the tfo task names.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"image", "when", "task"},
			},
		},
	}
}

func schema_pkg_apis_tf_v1beta1_ProxyOpts(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ProxyOpts configures ssh tunnel/socks5 for downloading ssh/https resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"host": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"user": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"sshKeySecretRef": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SSHKeySecretRef"),
						},
					},
				},
				Required: []string{"sshKeySecretRef"},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SSHKeySecretRef"},
	}
}

func schema_pkg_apis_tf_v1beta1_ResourceDownload(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceDownload (formerly SrcOpts) defines a resource to fetch using one of the configured protocols: ssh|http|https (eg git::SSH or git::HTTPS)",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Address defines the source address resources to fetch.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path will download the resources into this path which is relative to the main module directory.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"useAsVar": {
						SchemaProps: spec.SchemaProps{
							Description: "UseAsVar will add the file as a tfvar via the -var-file flag of the terraform plan command. The downloaded resource must not be a directory.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"address"},
			},
		},
	}
}

func schema_pkg_apis_tf_v1beta1_SCMAuthMethod(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SCMAuthMethod definition of SCMs that require tokens/keys",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"host": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"git": {
						SchemaProps: spec.SchemaProps{
							Description: "Git configuration options for auth methods of git",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitSCM"),
						},
					},
				},
				Required: []string{"host"},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.GitSCM"},
	}
}

func schema_pkg_apis_tf_v1beta1_SSHKeySecretRef(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SSHKeySecretRef defines the secret where the SSH key (for the proxy, git, etc) is stored",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name the secret name that has the SSH key",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace of the secret; Default is the namespace of the terraform resource",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"key": {
						SchemaProps: spec.SchemaProps{
							Description: "Key in the secret ref. Default to `id_rsa`",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lockSecretDeletion": {
						SchemaProps: spec.SchemaProps{
							Description: "Set finalizer from controller on the secret to prevent delete flow breaking. Works only with `spec.ignoreDelete = true`.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"name"},
			},
		},
	}
}

func schema_pkg_apis_tf_v1beta1_SecretNameRef(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SecretNameRef is the name of the kubernetes secret to use",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the secret",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace of the secret; Defaults to namespace of the tf resource",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"key": {
						SchemaProps: spec.SchemaProps{
							Description: "Key of the secret",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name"},
			},
		},
	}
}

func schema_pkg_apis_tf_v1beta1_Setup(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Setup are things that only happen during the life of the setup task.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"resourceDownloads": {
						SchemaProps: spec.SchemaProps{
							Description: "ResourceDownloads defines other files to download into the module directory that can be used by the terraform workflow runners. The `tfvar` type will also be fetched by the `exportRepo` option (if defined) to aggregate the set of tfvars to save to an scm system.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ResourceDownload"),
									},
								},
							},
						},
					},
					"cleanupDisk": {
						SchemaProps: spec.SchemaProps{
							Description: "CleanupDisk will clear out previous terraform run data from the persistent volume.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ResourceDownload"},
	}
}

func schema_pkg_apis_tf_v1beta1_Stage(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Stage is the current task of the workflow.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"generation": {
						SchemaProps: spec.SchemaProps{
							Description: "Generation is the generation of the resource when the task got started.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"state": {
						SchemaProps: spec.SchemaProps{
							Description: "State is the phase of the task pod.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"podType": {
						SchemaProps: spec.SchemaProps{
							Description: "TaskType is which task is currently running.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"interruptible": {
						SchemaProps: spec.SchemaProps{
							Description: "Interruptible is set to false when the pod should not be terminated such as when doing a terraform apply.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "Reason is a message of what is happening with the pod. The controller uses this field when certain reasons occur to make scheduling decisions.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"startTime": {
						SchemaProps: spec.SchemaProps{
							Description: "StartTime is when the task got created by the controller, not when a pod got started.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"stopTime": {
						SchemaProps: spec.SchemaProps{
							Description: "StopTime is when the task went into a stopped phase.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Message stores the last message displayed in the logs. It is stored and checked by the controller to reduce the noise in the logs by only displying the message once.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"podName": {
						SchemaProps: spec.SchemaProps{
							Description: "PodName is the pod assigned to execute the stage.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"podUID": {
						SchemaProps: spec.SchemaProps{
							Description: "PodUID is the pod uid of the pod assigned to execute the stage.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"generation", "state", "podType", "interruptible", "reason"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_tf_v1beta1_StageScript(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StageScript defines the different ways of sourcing execution scripts of tasks. There is an order of precendence of selecting which source is used, which is:\n 1. inline\n 2. configMapSelector\n 3. source",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"source": {
						SchemaProps: spec.SchemaProps{
							Description: "Source is an http source that the task container will fetch and then execute.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configMapSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMapSelector reads a in a script from a configmap name+key",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ConfigMapSelector"),
						},
					},
					"inline": {
						SchemaProps: spec.SchemaProps{
							Description: "Inline is used to write the entire task execution script in the tfo resource.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ConfigMapSelector"},
	}
}

func schema_pkg_apis_tf_v1beta1_TaskOption(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TaskOption are different configuration options to be injected into task pods. Can apply to one ore more task pods.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"for": {
						SchemaProps: spec.SchemaProps{
							Description: "For is a list of tasks these options will get applied to.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"policyRules": {
						SchemaProps: spec.SchemaProps{
							Description: "RunnerRules are RBAC rules that will be added to all runner pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/rbac/v1.PolicyRule"),
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels extra labels to add task pods.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotaitons extra annotaitons to add the task pods",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"envFrom": {
						SchemaProps: spec.SchemaProps{
							Description: "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvFromSource"),
									},
								},
							},
						},
					},
					"env": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of environment variables to set in the task pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Compute Resources required by the task pods.",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"script": {
						SchemaProps: spec.SchemaProps{
							Description: "Script is used to configure the source of the task's executable script.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.StageScript"),
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "RestartPolicy describes how the task should be restarted. Only one of the following restart policies may be specified.\n\n```go\n  const (\n    RestartPolicyAlways    RestartPolicy = \"Always\"\n    RestartPolicyOnFailure RestartPolicy = \"OnFailure\"\n    RestartPolicyNever     RestartPolicy = \"Never\"\n  )\n```\n\nIf no policy is specified, the restart policy is set to \"Never\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"volumes": {
						SchemaProps: spec.SchemaProps{
							Description: "Extra volumes for task pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						SchemaProps: spec.SchemaProps{
							Description: "Extra volumeMounts for task pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
				},
				Required: []string{"for"},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.StageScript", "k8s.io/api/core/v1.EnvFromSource", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount", "k8s.io/api/rbac/v1.PolicyRule"},
	}
}

func schema_pkg_apis_tf_v1beta1_Terraform(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Terraform is the Schema for the terraforms API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TerraformSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TerraformStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TerraformSpec", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TerraformStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_tf_v1beta1_TerraformSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TerraformSpec defines the desired state of Terraform",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"keepLatestPodsOnly": {
						SchemaProps: spec.SchemaProps{
							Description: "KeepLatestPodsOnly when true will keep only the pods that match the current generation of the terraform k8s-resource. This overrides the behavior of `keepCompletedPods`.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"keepCompletedPods": {
						SchemaProps: spec.SchemaProps{
							Description: "KeepCompletedPods when true will keep completed pods. Default is false and completed pods are removed.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"outputsSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "OutputsSecret will create a secret with the outputs from the module. All outputs from the module will be written to the secret unless the user defines \"outputsToInclude\" or \"outputsToOmit\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"outputsToInclude": {
						SchemaProps: spec.SchemaProps{
							Description: "OutputsToInclude is a whitelist of outputs to write when writing the outputs to kubernetes.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"outputsToOmit": {
						SchemaProps: spec.SchemaProps{
							Description: "OutputsToOmit is a blacklist of outputs to omit when writing the outputs to kubernetes.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"writeOutputsToStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "WriteOutputsToStatus will add the outputs from the module to the status of the Terraform CustomResource.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"persistentVolumeSize": {
						SchemaProps: spec.SchemaProps{
							Description: "PersistentVolumeSize define the size of the disk used to store terraform run data. If not defined, a default of \"2Gi\" is used.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"storageClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "StorageClassName is the name of the volume that terraform-operator will use to store data. An empty value means that this volume does not belong to any StorageClassName and will use the clusters default StorageClassName",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccount use a specific kubernetes ServiceAccount for running the create + destroy pods. If not specified we create a new ServiceAccount per Terraform",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"credentials": {
						SchemaProps: spec.SchemaProps{
							Description: "Credentials is an array of credentials generally used for Terraform providers",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Credentials"),
									},
								},
							},
						},
					},
					"ignoreDelete": {
						SchemaProps: spec.SchemaProps{
							Description: "IgnoreDelete will bypass the finalization process and remove the tf resource without running any delete jobs.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"sshTunnel": {
						SchemaProps: spec.SchemaProps{
							Description: "SSHTunnel can be defined for pulling from scm sources that cannot be accessed by the network the operator/runner runs in. An example is enterprise-Github servers running on a private network.",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ProxyOpts"),
						},
					},
					"scmAuthMethods": {
						SchemaProps: spec.SchemaProps{
							Description: "SCMAuthMethods define multiple SCMs that require tokens/keys",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SCMAuthMethod"),
									},
								},
							},
						},
					},
					"images": {
						SchemaProps: spec.SchemaProps{
							Description: "Images describes the container images used by task classes.",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Images"),
						},
					},
					"setup": {
						SchemaProps: spec.SchemaProps{
							Description: "Setup is configuration generally used once in the setup task",
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Setup"),
						},
					},
					"terraformModule": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformModule is used to configure the source of the terraform module.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Module"),
						},
					},
					"terraformVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "TerraformVersion is the version of terraform which is used to run the module. The terraform version is used as the tag of the terraform image  regardless if images.terraform.image is defined with a tag. In that case, the tag is stripped and replace with this value.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"backend": {
						SchemaProps: spec.SchemaProps{
							Description: "Backend is mandatory terraform backend configuration. Must use a valid terraform backend block. For more information see https://www.terraform.io/language/settings/backends/configuration\n\nExample usage of the kubernetes cluster as a backend:\n\n```hcl\n  terraform {\n   backend \"kubernetes\" {\n    secret_suffix     = \"all-task-types\"\n    namespace         = \"default\"\n    in_cluster_config = true\n   }\n  }\n```\n\nExample of a remote backend:\n\n```hcl\n  terraform {\n   backend \"remote\" {\n    organization = \"example_corp\"\n    workspaces {\n      name = \"my-app-prod\"\n    }\n   }\n  }\n```\n\nUsage of the kubernetes backend is only available as of terraform v0.13+.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"taskOptions": {
						SchemaProps: spec.SchemaProps{
							Description: "TaskOptions are a list of configuration options to be injected into task pods.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TaskOption"),
									},
								},
							},
						},
					},
					"plugins": {
						SchemaProps: spec.SchemaProps{
							Description: "Plugins are tasks that run during a workflow but are not part of the main workflow. Plugins can be treated as just another task, however, plugins do not have completion or failure detection.\n\nExample definition of a plugin:\n\n```yaml\n  plugins:\n    monitor:\n      image: ghcr.io/galleybytes/monitor:latest\n      imagePullPolicy: IfNotPresent\n      when: After\n      task: setup\n```\n\nThe above plugin task will run after the setup task has completed.\n\nAlternatively, a plugin can be triggered to start at the same time of another task. For example:\n\n```yaml\n  plugins:\n    monitor:\n      image: ghcr.io/galleybytes/monitor:latest\n      imagePullPolicy: IfNotPresent\n      when: At\n      task: setup\n```\n\nEach plugin is run once per generation. Plugins that are older than the current generation are automatically reaped.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Plugin"),
									},
								},
							},
						},
					},
					"requireApproval": {
						SchemaProps: spec.SchemaProps{
							Description: "RequireApproval will place a hold after completing a plan that prevents the workflow from continuing. However, the implementation of the hold takes place in the tf.sh script.\n\n(See https://github.com/GalleyBytes/terraform-operator-tasks/blob/master/tf.sh)\n\nDepending on the script that executes during the workflow, this field may be ignored if not implemented by the user properly. To approve a workflow using the official galleybytes implementation, a file needs to be placed on the workflow's persistent-volume:\n\n- <code>$TFO_GENERATION_PATH/\\_approved\\_\\<uuid-of-plan-pod></code> - to approve the workflow\n\n- <code>$TFO_GENERATION_PATH/\\_canceled\\_\\<uuid-of-plan-pod></code> - to deny and cancel the workflow\n\nDeleting the plan that is holding will spawn a new plan and a new approval will be required.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"terraformModule", "terraformVersion", "backend"},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Credentials", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Images", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Module", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Plugin", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.ProxyOpts", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.SCMAuthMethod", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Setup", "github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.TaskOption", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_tf_v1beta1_TerraformStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TerraformStatus defines the observed state of Terraform",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podNamePrefix": {
						SchemaProps: spec.SchemaProps{
							Description: "PodNamePrefix is used to identify this installation of the resource. For very long resource names, like those greater than 220 characters, the prefix ensures resource uniqueness for runners and other resources used by the runner. Another case for the pod name prefix is when rapidly deleteing a resource and recreating it, the chance of recycling existing resources is reduced to virtually nil.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "Phase is the current phase of the workflow",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastCompletedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "LastCompletedGeneration shows the generation of the last completed workflow. This is not relevant for remotely executed workflows.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"outputs": {
						SchemaProps: spec.SchemaProps{
							Description: "Outputs terraform outputs, when opt-in, will be added to this `status.outputs` field as key/value pairs",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"stage": {
						SchemaProps: spec.SchemaProps{
							Description: "Stage stores information about the current stage",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Stage"),
						},
					},
					"pluginsStarted": {
						SchemaProps: spec.SchemaProps{
							Description: "PluginsStarted is a list of plugins that have been executed by the controller. Will get refreshed each generation.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"podNamePrefix", "phase", "lastCompletedGeneration", "stage"},
			},
		},
		Dependencies: []string{
			"github.com/galleybytes/terraform-operator/pkg/apis/tf/v1beta1.Stage"},
	}
}

func schema_pkg_apis_tf_v1beta1_TokenSecretRef(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TokenSecretRef defines the token or password that can be used to log into a system (eg git)",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name the secret name that has the token or password",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace of the secret; Default is the namespace of the terraform resource",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"key": {
						SchemaProps: spec.SchemaProps{
							Description: "Key in the secret ref. Default to `token`",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lockSecretDeletion": {
						SchemaProps: spec.SchemaProps{
							Description: "Set finalizer from controller on the secret to prevent delete flow breaking Works only with spec.ignoreDelete = true",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"name"},
			},
		},
	}
}
